### 1834.[Grouping-Options](https://www.lintcode.com/problem/grouping-options/description)

一种比较复杂的dp设计是：定义dp[i][j][k]表示将i个数分成j组并且最后一组是k个元素，这种情况下的方案数。显然，它之前的状态就是dp[i-k][j-1][1,2,3...,k]，dp[i][j][k]是这些可能的前趋状态的和。这是一个o(N^4)级别的算法。

本题优秀的DP解法需要另辟蹊径来构造。很传统地，我们定义dp[i][j]表示为“将i个数分成符合题意的j组的方案数”。接下来，我们考察的关键是：如果确定了方案里的首元素大小为t，那么将这个方案里面的所有元素都减去t的话，剩下的问题就转化为了“将i-j\*t个数分成符合题意的j-1组的方案数”。这就实现了状态的转移！也就是说：
```cpp
dp[i][j]  = 0;
for (int t=0; t*j<=i; t++)
    dp[i][j] += dp[i-t*j][j-1];
```
但是需要特别注意，上面的状态定义dp[i][j]和转移方程，应该是允许```i==0```的。比如```i=4, j=4```的时候，我们尝试方案的第一个数字取1，那么dp[4][4]就转移到了dp[0][3]，这个时候我们需要承认```dp[0][3]==1```.事实上这也是合理的，因为虽然dp[0][3]看上去对应的是总数为零，但其实对应着第2到第4个数字都是1。同理，我们也可以分析，t也是应该从0开始枚举，即允许方案的第一个元素为零（因为每个元素其实代表的是与之前元素的差分）。比如说dp[4][3]可以转移到dp[4][2].

然而，在最high-level的层级中，第一个元素不能是零（不能代表差分）。因此dp[i][j]中分组数是m的时候（即最高层级的拆解），第一个元素的枚举只能从1开始！


