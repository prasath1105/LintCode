数字1-n，每个数字最多出现4次。问随机取m个数字，有多少种不同的组合。

=======================

#### 算法1： 基本型的dp

dp[i][j] 表示从前i种数字中取出j个数字，有多少种不同的组合。

考虑第i种数字我们能取几个？最少0个，最多4个。所以状态转移方程：
```cpp
for k = 0: 4
  dp[i][j] += dp[i-1][j-k] 
```
注意初始条件：dp[i][0] = 1

#### 算法2： 组合数学

本题相当于要求在n种数字里，选a种数字（每种取4次），b种数字（每种取3次），c种数字（每种取2次），d种数字（每种取1次），使得取数的总个数 4a + 3b + 2c + d = m

只要确定了一组(a,b,c,d)，那么能取到该组合的可能性有：
```
C(n, a) * C(n-a, b) * C(n-a-b, c) * C(n-a-b-c, d)， 其中 C(m,n)是组合数，即从m个数里取n个的种类。
```
所以外层三重循环来确定(a,b,c,d)，内层算四个组合数的乘积。
```cpp
for (int a=0; (a<=n && a*4<=m); a++)
    for (int b=0; (a+b<=n && a*4+b*3<=m); b++)
        for (int c=0; (a+b+c<=n && a*4+b*3+c*2<=m); c++)
        {
            d = m-(a*4+b*3+c*2);
            ret *= C(n, a) * C(n-a, b) * C(n-a-b, c) * C(n-a-b-c, d);
        }
```
如何高效计算组合数呢？有一种常见的方法，利用组合数的递推公式：```C(m,n) = C(m-1, n) + C(m-1, n-1)```

递归的边界就是 C(m,0) = 1 和 C(m,1) = m

我们结合记忆化的技巧，在递归的过程中将所有C[m][n]的中间结果就记录下来，可以加快效率。

