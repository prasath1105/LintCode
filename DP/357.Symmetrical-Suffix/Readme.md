#### Description
```
给定一个字符串 s。
我们令一个字符串的权值为一个字符串的最长对称前后缀长度。
请求出 s 的所有子串的权值的总和。

例如，
"abcxyzcba" 的最长对称前后缀的长度为 3
"abcba" 的最长对称前后缀的长度为 5

The string is of length nn, 1 <= n <= 1e3
```
#### 思路：
"abcxyzcba" 和 "abcba" 这两个例子很令人迷惑。前者的前缀/后缀并不重合，但后者的前缀/后缀重合到了一起。
为了消除这种麻烦，我们换一个问题：限制“回文前缀”的定义不能与后缀完全重合。最极端的情况就是前缀和后缀各一半。
比如 "abc|xyz|cba" -> abc, "ab|c|ba" -> abc

我们令dp[i][j]表示s[i:j]这个子串，最长的“回文前缀”长度。
显然对于回文的常用处理手段，就是"两端剥离"，将问题转移至[i+1:j-1]区间。容易写出状态转移方程：
```
```cpp
if (s[i]==s[j])
	dp[i][j] = 1+dp[i+1][j-1];
else
	dp[i][j] = 0;
```  
由此我们可以用 o(n^2) 计算出所有的dp。

那么本题所希望的答案是什么呢？
显然，如果“回文前缀”和“回文后缀”不重合，那么答案就是 ret += dp[i][j].  e.g. "abcxyzcba" -> 3
否则，如果“回文前缀”和“回文后缀”重合，意味着整个子串就是回文串，答案就是这个子区间的长度 ret += j-i+1. e.g. "abcba" -> 5

如何判断“回文前缀”和“回文后缀”是否重合呢？只要看dp[i][j]*2的和区间长度的大小即可。
如果dp[i][j]*2 == j-i+1，说明这是一个偶数长度的回文串。
如果dp[i][j]*2-1 == j-i+1，说明这是一个奇数长度的回文串。
