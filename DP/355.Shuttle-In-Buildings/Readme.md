#### Description
```
蜘蛛侠在大楼间穿梭。大楼的高度可以看作是一个从左到右排列的数组。
现在蜘蛛侠站在第一栋大楼上，他想跳到最后一栋上。
蜘蛛侠的视野为 k，他可以花费 x 点体力，用蛛丝移动到右侧 k 幢建筑中第一栋比当前位置高的大楼。
或者蜘蛛侠可以花费 y 点体力，跳跃到右侧接下来两栋大楼其中一栋。
请计算蜘蛛侠最少花费多少体力，到达最后一栋上。

大楼的高度为数组 heightsheights，一共有 n 栋大楼，2 <= n <= 1e5
```

#### 思路：栈+dp
```
我们考虑到达第i座楼的最小花费体力。令其为dp[i]. 有三种前趋状态：
1. 从前一幢楼过来 dp[i] = dp[i-1]+y
2. 从前前幢楼过来 dp[i] = dp[i-2]+y
3. 从符合条件的前面的楼“跳”过来，dp[i] = dp[j]+x, for all eligible j
  哪些楼j符合条件呢？我们发现对于任意的楼，它能跳跃到的楼是固定的。也就是右边k幢楼里面的第一个比它高的。
  这就是一个next greater element 问题，是单调栈的经典应用。参考 LeetCode 503. Next Greater Element II
  我们提前处理heights数组，计算每一幢楼j可以跳跃到的目的地i。再反向用hash表存储，每一幢楼i可以从哪些j跳跃过来。

Next Greater Element 
遍历数组元素，同时维护一个数值递减的栈（其实我们在栈里存放的是index，需要用heights[index]来映射数值）
1. 如果新元素的数值比栈顶元素更小，则加入栈。
2. 如果新元素的数值比栈顶元素更大，则说明栈顶元素的next greater element就是这个新元素（本题中还要查验index的距离是否小于k）。
将此记录下俩之后，就将栈底元素弹出。
这个退栈操作可以重复，直至不满足条件。然后再将新元素放入。
```
