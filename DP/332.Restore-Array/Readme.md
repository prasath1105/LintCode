#### Description
```
小九有一个长为 n 的整型数组，数组中的每个数都在 l 和 r 之间，而且数组的和是 3 的整数倍。
请帮小九计算出这个数组一共有多少种不同的可能。
输出要对 10^9+7取模
```
#### 思考：
```
令k = r-l+1 表示每个数字有k种选择。
我们可以预先计算出这k个数里面有多少个数被3除余0,1,2. 我们分别记做n0, n1, n2.

如果没有要求数组的和是3的倍数，那么答案就是 k^n，原因是任何一个数字的选择都没有任何限制，即每一个数字都可以在k个值里任选。
现在要求数组总和是3的倍数，说明对每个数字的选择有了限制。显然这个限制是关于模3的余数。

当前问题是“前n个数的和是3的倍数”有多少种可能。设想我们需要确定最后一位的数字，那么我们能怎么选择num[n]呢？有三种并列的情况：

1. 如果num[n]%3==0，那么我们希望sum[1:n-1]%3==0。
   已知能被3整除的个数是n0，问题就转化为了“前n-1个数的和是3的倍数”有多少种可能。

2. 如果num[n]%3==1，那么我们希望sum[1:n-1]%3==2。
   已知能被3除余1的个数是n1，问题就转化为了“前n-1个数的和被3除余2”有多少种可能。   

3. 如果num[n]%3==2，那么我们希望sum[1:n-1]%3==1。
   已知能被3除余1的个数是n2，问题就转化为了“前n-1个数的和被3除余1”有多少种可能。      

我们发现了递归的痕迹。如果我们想知道“前n-1个数的和被3除余0/1/2”有多少种可能，就要知道“前n-2个数的和被3除余0/1/2”有多少种可能...

所以令dp[i][r]表示前i个数字的和被3除余r，有多少种排列的可能。那么状态转移方程就是：
dp[i][0] = dp[i-1][0] * n0 + dp[i-1][1] * n2 + dp[i-1][2] * n1
dp[i][1] = dp[i-1][0] * n0 + dp[i-1][1] * n0 + dp[i-1][2] * n2
dp[i][2] = dp[i-1][0] * n2 + dp[i-1][1] * n1 + dp[i-1][2] * n0

从小到遍历i，就可以求出所有的dp[i][r]。最终答案是dp[n][0].

PS. 如何高效计算n0,n1,n2? 
第一步：n0 = n1 = n2 = k/3.
第二步：
    如果k%3==0，不做改动；
    如果k%3==1，说明最后一个元素是"零头",那么n[r%3]+=1; 
    如果k%3==2，说明最后两个元素都是"零头",那么n[r%3]+=1, n[(r-1)%3]+=1;;
```    
