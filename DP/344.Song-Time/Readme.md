#### Description
```
给定长度为N的正整数 数组song代表N首歌的时间,
请你任选其中若干首播放，在满足开始播放最后一首歌的时间小于M的情况下 求播放歌曲的最长时间
每首歌只能被播放一次
你可以任意指定播放顺序

1≤N≤10^3 
1≤M≤10^5
1≤song[i]≤10^5
```
#### 分析：
```
我们发现最后一首歌有着“特权”，只要它早于M时刻播放，那么它无论放多久时间都被允许。
那么显然，我们会把最长的歌曲放在最后一个位置上，这是最优的策略。

刨去了最长的一首歌，于是接下来的问题，就是总时长小于M的约束下，最长能排多少时间的歌曲（每首歌曲只能用一次或者不用）。
这是一个典型的01背包问题。模板如下：

for (int i=0; i<songs.size(); i++) // 枚举物品

	考虑如果我用了第i首歌，能够排满哪些时长？

	for (int t=1; t<M; t++) // 枚举容量

		我用了第i首歌，能否排满总时长t？这取决于我在用第i首歌之前，是否已经能排满总时长t-songs[i].
		if (dp[i-1][t-songs[i]] == true) 
			dp[i][t] = true

最终再遍历一遍t，找到最大的t_max，需要满足dp[n-1][t_max]==true。即考察完n首歌之后能够安排的最长时长
最终的答案是 t_max + 最长的歌的长度
```
