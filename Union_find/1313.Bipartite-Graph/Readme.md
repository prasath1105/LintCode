给定一个完全图，请你把点分成两类，最小化端点为相同种类的边的权值的最大值.
每类的点的数量不少于2.

类似题：LC 	785	Is Graph Bipartite?    

思想：

显然，我们会把所有的edge按照长度从大到小排序。为了最小化题目所求的值，我们要尽量把长的edge的两个端点分在不同的group。

在逐条处理edge的过程中，如果发现某条边没法将两个端点拆在不同的group，那么这条边就是答案。

那么为什么会出现“某条边没法将两个端点拆在不同的group”的情况呢？这是因为在处理之前的edge时，会给node带来各种约束。

比如：
```
最长边 a-b，我们必然会将a和b拆开。
次长边 a-c, 我们必然会将a和c拆开。这就意味着b和c必然会在一组。
第三长边 b-c，这时候我们就发现无法将b和c拆开了，因此这条边就是答案。
```
从上可以看出，对于所有不想与a在同一组的点，都必须从此“连”一起。同理，对于所有不想与b在同一组的点，也必须“连”在一起。。。在上面的例子中，我们可以记录bans[a] = {b, c, ...}

以后遇到任何一条新的edge，我们先判断它的两个端点x和y是否已经被“连”在了一起。是的话，那么只好输出这条边为答案。如果不是的话，我们就将x和 “所有不想与y在同一组的点” 连在一起（标记同一组）。

同理，我们还需要就将y和 “所有不想与x在同一组的点” 连在一起。

什么样的数据结构最适合这种“快速判断两个点是否联通”、“快速将两个点标记属于同一组”呢？显然就是并查集 Union Find.

Union Find 提供两个函数：FindSet(node) 查看某个node所述的集合代号。所有同属于一个集合的node都有相同的代号。Union(node1, node2)，将两个node标记同属一个集合。

特别注意，题目还有一个要求“每类的点的数量不少于2”。怎么解决呢？当我们拆分完某条边x-y时，发现bans[x]的个数等于n-1的时候，就意味着违反了这个要求。说明这条边无法成功处理（即无法拆分端点为两组），因此输出这条边为答案
