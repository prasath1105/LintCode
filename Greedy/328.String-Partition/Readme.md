#### Description
给出一个字符串，均为大写字母，将这个字符串划分成尽可能多的部分，使每种字母只会出现一个部分中。返回一个数组包含每个部分的长度。

类似题：LeetCode 1520. Maximum Number of Non-Overlapping Substrings

#### 思路：
```
因为所有的字母必须在一个子串中，所以满足条件的子串最多不超过26个子串。
如果我们把这些子串按照起始字母分类，同理也不会超过26个。我们可以将它们找出来，方法如下：

e.g. X X X [a ... b ... c... a ...c ... b] X X

我们想找以a开头的合法子串（该子串里出现的字母只会出现在该子串里）。
首先找到 a_min 的位置，那么[a_min, a_max]必然都属于这个子串。
我们在遍历[a_min, a_max]的过程中，如果遇到了b_min，那么[b_min, b_max]也必然在这个子串中，因此子串的右界要顺延为 right = max(a_max, b_max).
我们在继续遍历这个子串（永远朝右边界进发）的过程中，如果遇到了c_min，那么[c_min, c_max]也必然在这个子串中，因此子串的右界要顺延为 right = max(right, c_max).
以此类推，直到顺利走到了右边界 right，那么[a_min, right]就是一个合法的子串。

注意，如果遇到的一个b不是b_min，那么就需要中断这个子串的查找
e.g. X b X X [a ... b ... c... a ...c ... b] X X
意思就是：我们永远不可能找到一个以a开头、满足条件的子串。因为第一个b的存在先于a_min，而又有其他的b存在于[a_min,a_max]之间。

由此分析，我们实际上可能会找到少于26个子串。这些子串的特点是：起始字母不同、满足条件（所有在这个子串出现过的字母只在这个子串出现）。
由此可知，这些子串不可能是互相overlap的。
a..........
      b .......
但是这些子串可能是互相嵌套的：
a...............a
      b ... b
所以我们需要将嵌套的子串过滤掉。怎么过滤？暴力一下，总共就最多26*26种配对，查看每一对区间是否是嵌套关系即可。

将嵌套的子串过滤之后，剩下的这些子串一定就是互斥、互补的关系。按照左端点先后排序即可。
```
