#### 题目：

有一种编程语言，只有以下五种命令，每种命令最多有两个参数，请检查给定的程序是否 可能 无限循环。
这些命令分别是：
label <string>：声明一个标签，参数是一个字符串，且每个标签只声明一次。
goto <string>：跳转到一个标签，并从标签处开始按顺序执行程序。
halt：停机，程序终止。
print <string>：打印一个字符串，并执行下一个命令。
gotorand <label1> <label2>：随机跳转到两个标签中的一个，并从标签处开始按顺序执行程序。
当程序执行完最后一句，且没有跳转时，程序终止。

#### Example
输入：
```
0：label start
1：print "hello world!"
2：gotorand start end
3：print "good bye"
4：halt
5：label end
```
本题通过程序流程的设定，能够构建一个有向图。
```
0->1
1->2
2->3
3->4
2->0
2->5
```
如果这个图中，从0出发，如果能遇到任何“环”，说明就会陷入循环。（注意，不是说图中有环就会陷入循环。 0—>1->4, 2->3->2）

在一个有向图中判断是否有环。一般有DFS和BFS两种做法。（类似题：LeetCode 207.Course-Schedule）

#### 解法1： DFS
DFS的基本思想是从任意一个未访问过的节点开始做DFS的遍历。如果在某条支路的遍历过程中（没有遍历到出度为0的端点）遇到了任何在这条支路中已经访问过的节点，那么就能判断成环。

注意，“遇到了任何在这条支路中已经访问过的节点”和“遇到了任何已经访问过的节点”，是不同的概念。比如：
```
0-> 1 -> 2 -> 3 -> 4 
              ^
 -> 5 -> 6 -> 7 -> 8 
              ^____|
```
我们从0开始依次访问0->1->2->3->4，然后遍历结束。然后从支路5开始依次访问5->6->7->3的时候，3已经被访问过了。但是这不会误判成环。因为3并不是在当前未完待续的支路中。

我们再看5->6->7->8->7这条线路，此时的7已经被这条支路访问过，并且这条支路并没有走到底，这个时候就应该判断成环。

所以我们需要标记两种visited[i]。
a. 如果节点i已经在其他遍历到底的支路中被访问过了，标记1.
b. 如果节点i是在当前未完待续的支路中被访问过了，标记2. 只有在遍历过程中遇到了2，才算是判断有环。

那么是什么时候标记1什么时候标记2呢？方法是：在某条DFS的路径上，第一次遇到的节点i的时候标记2. 在回溯返回节点i的时候标记1
（因为能成功返回的话，说明后续的节点都没有环，都是死胡同，此后任何任何入度指向这个节点i的话，我们都不用担心后续的遍历会遇到环）.

核心的dfs代码很简单：
```cpp
    bool dfs(int cur)
    {
        visited[cur] = 2;
        for (int next: graph[cur])
        {
            if (visited[next]==1) continue;
            if (visited[next]==2) return false;
            if (dfs(next)==false)  return false;
        }
        visited[cur] = 1;
        return true;
    }
```

#### 解法2： BFS
BFS的算法思想是拓扑排序：从外围往核心进发。我们每次在图中找出度为0的点，然后移除。如果最后没有出度为0的点，但是图中仍有点存在，那么这些剩下来的点一定是交错成环的。
```
        PutOutDegreeZeroNodesIntoQuque(q);

        while (!q.empty())
        {
            int cur = q.front();
            visited[cur] = 1;
            q.pop();
            for (auto prev: prev[cur])
            {
                OutDegree[prev]--;
                if (OutDegree[prev]==0)
                {
                    q.push(prev);                    
                }                    
            }
        }        

        return visited[0]==1;
```
