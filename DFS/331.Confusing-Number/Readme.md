### 331. Confusing Number
#### description
```
拍卖会上有k个参与者，每个人都举了一个牌子，牌子上的数字分别是1-k。
为了防止有人举牌子的时候180°旋转导致混淆了牌子上的数字，需要将一些会导致混淆的数字加上下划线。
比如当0、1、6、8、9旋转180度时，它们分别变为0、1、9、8、6。而2、3、4、5、7 旋转 180° 后，是无法得到任何数字的。
易混淆数（Confusing Number）指的是一个数字在整体旋转 180° 以后，能够得到一个和原来不同的数，
且新数字的每一位都应该是有效的、并且还在1-k的范围内。

给出正整数 k，请你返回此时易混淆数字的数量。

1≤k≤1000000000
```

#### 分析：
```
混淆数的要求：
1. 只能由0,1,6,8,9组成。
2. 它的“颠倒数”不能与原数相同。

本题和 LeetCode 1088. Confusing Number II 很类似，但是有更多的两条限制。
3. 一个合法的混淆数，需要本身或者他的“颠倒数”都不能有leading zeros
4. 一个合法的混淆数，需要本身或者他的“颠倒数”都不能超过k。


第一类：长度小于len

假设k的长度是len，那么对于任何长度n小于len的数字(n=1,...,len-1)而言，我们都不用担心第4点。因此我们有数学解法：

n位的混淆数的个数 = 合法数的总个数 - “颠倒数”与原数相同的合法数个数

其中，合法数的总个数 = 4 * 5 * 5 * ... * 5 * 5 * 4    
第一位、最后一位的选择只能是1,6,8,9；其他位的选择可以是 0,1,6,8,9                                
        return 4*pow(5,n-2)*4;

“颠倒数”与原数相同的合法数个数: [X X X ... X] Z [Y ... Y Y  Y]
                                 4*5*5 ... 5* 3
第一位的选择只能是1,6,8,9；中间位的选择只能是0,1,8；其他位的选择可以是 0,1,6,8,9                                
        if (n%2==0)        
            return 4*pow(5,n/2-1);
        else
            return 4*pow(5,n/2-1)*3;
  
第二类：长度等于len
可以用暴力的dfs，逐位生成数字。除第一位外，每位数字最多五种可能，总共最多9位数字，
5^9 = 1953125，加上剪枝，复杂度可以接受

for (int curNum = 1,6,8,9)
    dfs(curNum,0);


dfs(string curNum, int pos)
{
    if (curNum[0:pos] > k[0:pos]) 
        return;
    if (pos==k.size())
    {
        if (checkConfusing(curNum))
            count++;
    }
    
    for (auto x:{'0','1','6','8','9'})        
        dfs(curNum+x, pos+1);
}

在checkConfusing里面，我们检查三点：
1. 它的颠倒数是否大于k，
2. 它的颠倒数是否有leading zero
3. 它的颠倒数是否与本身相等。 
满足任何一点就返回false
```
