#### Description:
给你一个数字N, 返回最大的比N小的、且每一位是连续递增的数字

#### 思路：深度优先搜索。
```
假设N = a b c d...
无脑搜索：
第一个位置可以是a~1
第二个位置可以是9~1
第三个位置可以是9~1
...
对于每一位，我们都优先搜索较大的digit。因为一旦成功搜索到符合条件的解（即连续递增，且小于N），那么就一定是最大的解。

假设我们递归构造的数字是M，当前构造的是第i位（从高位开始），那么这个递归的终止条件有两个：
1. 要满足连续递增，必须 M[i] > M[i-1] 
2. 要满足 M < N 。 如何判断？
(a) 如果 M[0:i-1] == N[0:i-1]，那么当前位M[i]的选择不能大于 N[i] （如果i是最后一位，那么M[i]只能小于N[i]）
    eg   N = 1 3 5  7 ...
         M = 1 3 5 [7] ...

    eg   N = 1 3 5 6  8
         M = 1 3 5 6 [7]

(b) 如果 M[0:i-1] < N[0:i-1]，那么当前位M[i]的选择可以是任意（即9~1)
    eg   N = 1 3 5 6  8  ...
         M = 1 3 4 6 [9] ...

这个搜索过程如果能顺利地进行到 i==N.size()，说明成功构造了一个长度与N一样、满足递增关系、且不大于N的一个M。
然后就可以果断终止搜索，因为这一定是最大解。

如果以上的搜索结束之后并没有合法的答案，那么可以构造一个短一位的整数。
这个整数因为少一位数字，所以肯定小于N。我们用上最大的digits就行。即将9,8,7,6...逆序排列。
N = 12345   => M = 6789

考虑到无论怎么构造，M最大就是123456789。
如果N>123456789，那么直接输出123456789
```
